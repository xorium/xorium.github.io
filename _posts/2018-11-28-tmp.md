---
layout: post
title:  "Черновик"
date:   2018-11-28 22:51:05 +0300
---
## Mutable & Immutable
В питоне все builtin типы данных делятся на 2 категории: изменяемые (mutable) и неизменяемые (immutable).
Изменяемые - это, как правило, сложные типы, внутри которых хранится какая-то информация, которую можно изменять **частями**.
Неизменяемые - это типы, которым можно присвоить что-то, но нельзя потом изменить **частично**.
Вот, собственно, [таблица изменяемости типов](https://i.imgur.com/flmB6df.png).  

Теперь нужно выделить 2 основных момента, вызывающих недопонимание, как правило, у большинства новичков и женщин.
1. *Частичность* - изменяемость говорит там о том, что мы можем поменять какую-то информационную единицу в переменной изменяемого типа.
Именно поэтому строки являются immutable:
```python
s1 = "test"
l1 = ["t", "e", "s", "t"]
s1[2] = "x" # не пролезет - выскочит TypeError
l1[2] = "x" # зашло!
```
2. *Реинициализаця* или по-нашенски - полностью поменять инфу в переменной.
Этот пункт является ответом умникам, которые заливают, мол, я могу букву конкатенацией изменить: `s1 = s[:2] + "x" + "s[3]`. Это и есть реинициализация - мы присваиваем переменной `s1` уже абсолютно новое значение, полученное той самой конкатенацией.
Другими словами, не надо путать *изменение значения* и *изменение переменной*, где это значение лежит.  

### А теперь все по понятиям - примеры кода.
Рассмотрим задачу возведения в квадрат множества чисел. Они могут храниться в списке или в любом итерируемом объекте.  
Решение заточенное конкретно на изменяемые типы - списки/сеты:
```python
# Возводим в квадрат элементы любого итерируемого
# mutable объекта.
def square_mutable(nums_list):
    for i, num in enumerate(nums_list):
        nums_list[i] = num**2
        # num = num**2 нельзя! ведь в только хранит значение, а
        # значит это будет реинициализация.

lst = [1, 2, 3]
square_mutable(lst) # отквадрируем список
print(lst) # чекнем результат: [1, 4, 9]
```
Решение, заточенное под неизменяемые типы - фрозен сеты, генераторы и др.
```python
# Возводим в квадрат элементы любого итерируемого
# immutable объекта.
def square_immutable(nums_list):
    new_list = [num**2 for num in nums_list]
    return new_list

lst = [1, 2, 3]
print(square_immutable(lst)) # также: [1, 4, 9]
```
Это решение создает новый список и добавляем туда возведенные в квадрат элементы, итерируясь по переданному в аргементе итератору. То есть опять же - создание новой переменной, основываясь на данных из immutable переменной (как со строкой).  
Также стоит заметить, что второй вариант будет работать с любой структурой, которая является итератором и хранит числа, пусть и жрет больше памяти, чем первый вариант.  

Больше сложности меньше синтетики.  
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l3 = [7, 8, 9]
total = [l1, l2, l3]
for l in total:
    # вычисляем список квадратов элементов и...
    # сохраняем его в никуда, так как l - это просто контейнер для текущего
    # подсписка, этот контейнер хранит в себе подсписок в каждой итерации 
    # и может быть перезаписан чем-то еще, но это не перезапишет сам 
    # подсписок, который хранился в l, а только саму переменную l.
    l = [n**2 for n in l]

print(l1) # [1, 2, 3]
```
Правильно:
```python
for i, l in enumerate(total):
    total[i] = [n**2 for n in l]
```

Трудно переоценить сложность этой темы, поэтому мусолить ее дальше смысла не вижу. Хотя, может быть, позже добавлю пару интересных случаев, если ~~придумаю~~ встречу на практике.
