---
layout: post
title:  "SQL vs NoSQL"
date:   2018-11-28 22:51:05 +0300
---
## Реляционная модель и SQL
> Начинай с малого, не сойдешь за отсталого.  

Поэтому начнем с истории о том, как появились реляционки, что это такое и почему они. Всем просвященным или принципиально не читающим теорию и исторические сводки можно преспокойно скипнуть дальше.  

Было время (около 1955), когда программисты были настолько суровы, что работали напрямую с диском на уровне цилиндров, секторов и головок - люди реально писали самопальные СУБД для конкретных дисков, выполняющие преобразование относительных адресов в абсолютные.  
Но все начало становиться интересней, когда вычислительные мощности стали расти нелинейными темпами и давали возможность развернуть схемы данных покрупнее за теже бабки, но вот мозг у человеков оставался до неприличия постоянен.  
Поэтому растущая сложность такого подхода с одной стороны (попробуйте запомнить детали, какие цилиндры, размеры секторов под какую сущность заточены, когда у вас не 5-7, а хотя бы 15-17 сущностей) и увеличение объема дисков за те же деньги - с другой, привели к тому, что сильнейшие умы нашего вида стали делать именно то, что мы всегда делаем, когда хотим снизить возрастающую сложность - переход на следующий более высокий уровень абстракции. То есть мы стали подумывать над *моделями данных*.  

**Модель данных** - это, грубо говоря, какое-то описание того, по каким правилам данные будут упорядочиваться, добавляться и изменяться на диске.  
Математиками быстро были синтезированы различные, говоря задним числом, немного холливарные, модели данных с такими названиями как: [сетевая](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) и [иерархическая](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85). На подробностях останавливаться не будем, но заметим немаловажный факт: к этим моделям стали разрабатыавть **системы управления базами данных** (СУБД) - программы, реализующие в себе ту или иную модель, берущие на себя все сложные алгоритмические изыски и скрывающие множество низкоуровневых деталей. Так для сетевой модели была популярна Integrated Data Store (IDS), а для иерархической - IBM Information Management System (IMS).  
Эта избавило разработчиков от заботы о низкоуровневых деталей дисков и самое главное - от сложности и многообразия структур данных и алгоритмов манипуляций над ними. То есть теперь любой рядовой разраб при заканчивающимся дисковом пространстве мог относительно спокойно вмонтировать еще один диск, за вести на него еще одну СУБД и, воспользовавшись выигранным временем, пойти вмонитровать пивандрия.  
Вся эта движуха длилась до конца 60-х голов, когда Эдгар Кодд сформулировал и изложил принципы *реляционной модели*. 
  

Итак, реляционная модель - продукт теории построения баз данных на основе таких фундаментальных разделов математики, как теория множеств и логика (исчисление предикатов) первого порядка.
Если опустить слишком умные понятия и перейти к более прикладным, то реляцоинная модель суть есть 3 вещи:
* Данные в базе представляют собой набор отношений (таблиц) - структурный аспект;
* Отношения (таблицы) отвечают определенным условиям целостности - целостный аспект;
* Есть поддержка операторов манипулирования отношениями - манипуляционный аспект;  

Теперь по каждому пункут человеческим языком.  
### Стурктурный аспект.  
Он фиксирует тот факт, что модель описывает любой набор данных, как *нормализованные отношения*. 
Отношение - это формальный термин (из теории множеств) неформального слова "таблица", так что дальше интерпретируйте эти два слова, как синонимы. *Нормализация* - это устранение избыточности и несогласованности данных. Существуют свойства, характеризующие отношение с точки зрения избыточности, они основаны на строгой теории нормализации. Каждое такое свойство называется [нормальная форма](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0).  
Погодите прекращать нервничать, если все еще непонятно, сейчас будет дан (немного грубоватый) пример.  
Итак, у нас есть набор данных о работниках какой-то фирмы, ее проектах и клиентах.
```
Сотрудники:  
- Программист Петя Дедлайнов, 32 года, работает над проектом "Ping";
- Программист Вова Дебагин, 25 лет, работает над проектом "Pong";
- Менеджер Ваня Заебцов, 29 лет, работает над проектоми "Ping" и "Pong";
Проекты:  
- Ping, заканчивающийся 2019-01-01;
- Pong, заканчивающийся 2020-02-02;
Клиенты:  
- Динг, 30 лет, заказал реализацию проекта Ping;
- Донг, 40 лет, заказал реализацию проекта Pong;
```
Наша задача составить схему данных по реляционной моделе. 
Очевидно, выделяющиеся сущность - сотрудники и клиенты, они должны будут выделены в обособленные таблицы (отношения). А вот выделять ли для проектов отдельную таблицу пытливому уму новичка может показаться неясным.  
То есть можно сделать 2 таблицы и запихать в них все:
Сотрудники

|EID   | Имя           | Фамилия       | Возраст  | Должность | Проект |
| ---- |:-------------:|:-------------:| --------:|----------:|-------:|
|...   |...            |...            |...       |...        |...     |

Клиенты

|CID   | Имя           | Возраст  | Проект |
| ---- |:-------------:| --------:|-------:|
|...   |...            |...       |...     |

Или можно создать 2 таблицы:
Сотрудники

|EID   | Имя           | Фамилия       | Возраст  | Должность | Проект ID |
| ---- |:------------- |:-------------:| --------:|----------:|----------:|
|...   |...            |...            |...       |...        |...        |

Клиенты

|CID   | Имя           | Возраст  | Проект ID |
| ---- |:------------- | --------:|----------:|
|...   |...            |...       |...        |

Проекты

|PID   | Название      | Дата окончания  |
| ---- |:------------- | ---------------:|
|...   |...            |...              |


Вот тут-то и нужно вспомнить про нормализацию, ведь если мы проекты сделаем столбцами для каджой из двух первых таблиц


Итак, что такое *реляционная база данных* (РБД) - это БД, основанная на одноименной модели данных (РМД)




В питоне все builtin типы данных делятся на 2 категории: изменяемые (mutable) и неизменяемые (immutable).
Изменяемые - это, как правило, сложные типы, внутри которых хранится какая-то информация, которую можно изменять **частями**.
Неизменяемые - это типы, которым можно присвоить что-то, но нельзя потом изменить **частично**.
Вот, собственно, [таблица изменяемости типов](https://i.imgur.com/flmB6df.png).  

Теперь нужно выделить 2 основных критерия изменяемости, вызывающих недопонимание, как правило, у большинства новичков и женщин.
1. *Частичность* - изменяемость говорит там о том, что мы можем поменять какую-то информационную единицу в переменной изменяемого типа.
Именно поэтому строки являются immutable:
```python
s1 = "test"
l1 = ["t", "e", "s", "t"]
s1[2] = "x" # не пролезет - выскочит TypeError
l1[2] = "x" # зашло!
```
2. *Реинициализаця* или по-нашенски - полностью поменять инфу в переменной.
Этот пункт является ответом умникам, которые заливают, мол, я могу букву конкатенацией изменить: `s1 = s[:2] + "x" + "s[3]`. Это и есть реинициализация - мы присваиваем переменной `s1` уже абсолютно новое значение, полученное той самой конкатенацией.
Другими словами, не надо путать *изменение значения* и *изменение переменной*, где это значение лежит.  

### А теперь все по понятиям - примеры кода.
Рассмотрим задачу возведения в квадрат множества чисел. Они могут храниться в списке или в любом итерируемом объекте.  
Решение заточенное конкретно на изменяемые типы - списки/сеты:
```python
# Возводим в квадрат элементы любого итерируемого
# mutable объекта.
def square_mutable(nums_list):
    for i, num in enumerate(nums_list):
        nums_list[i] = num**2
        # num = num**2 нельзя! ведь в только хранит значение, а
        # значит это будет реинициализация.

lst = [1, 2, 3]
square_mutable(lst) # отквадрируем список
print(lst) # чекнем результат: [1, 4, 9]
```
Решение, заточенное под неизменяемые типы - фрозен сеты, генераторы и др.
```python
# Возводим в квадрат элементы любого итерируемого
# immutable объекта.
def square_immutable(nums_list):
    new_list = [num**2 for num in nums_list]
    return new_list

lst = [1, 2, 3]
print(square_immutable(lst)) # также: [1, 4, 9]
```
Это решение создает новый список и добавляем туда возведенные в квадрат элементы, итерируясь по переданному в аргементе итератору. То есть опять же - создание новой переменной, основываясь на данных из immutable переменной (как со строкой).  
Также стоит заметить, что второй вариант будет работать с любой структурой, которая является итератором и хранит числа, пусть и жрет больше памяти, чем первый вариант.  

Больше сложности меньше синтетики.  
```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l3 = [7, 8, 9]
total = [l1, l2, l3]
for l in total:
    # вычисляем список квадратов элементов и...
    # сохраняем его в никуда, так как l - это просто контейнер для текущего
    # подсписка, этот контейнер хранит в себе подсписок в каждой итерации 
    # и может быть перезаписан чем-то еще, но это не перезапишет сам 
    # подсписок, который хранился в l, а только саму переменную l.
    # Также это действие не соответствует 1-му критерию изменяемости.
    l = [n**2 for n in l]

print(l1) # [1, 2, 3]
```
Правильно:
```python
for i, l in enumerate(total):
    total[i] = [n**2 for n in l]
```

Трудно переоценить сложность этой темы, поэтому мусолить ее дальше смысла не вижу. Хотя, может быть, позже добавлю пару интересных случаев, если ~~придумаю~~ встречу на практике.
