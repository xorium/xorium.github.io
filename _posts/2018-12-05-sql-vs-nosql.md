---
layout: post
title:  "SQL vs NoSQL"
date:   2018-11-28 22:51:05 +0300
---
*Дисклеймер: данная статья построена таким образом, что сначала идут немного формальные определения (сложные слова, термины, неполиткорректные высказывания), которые могут вызывать у читателя небольшие приступы развития интеллекта, сонливость, желание прекратить читать и т.д. Это абсолютно нормальная реакция здорового мозга на информацию с высокой степенью новизны и сложности, поэтому автор настоятельно рекомендует продолжать читать дальше до развернутых пояснений, после которых, скорее всего, все встанет на места.*  
  
В данном посте будут относительно детально описаны реляционные и некоторые нереляционные БД. Читатель узнает как все начиналось в контексте баз данных, к чему пришло, чем отличаются NoSQL от реляционных конкурентов, собственно, в чем их различия и props&cons.

## Реляционная модель и SQL
> Начинай с малого, не сойдешь за отсталого. — народная поговорка 

Начнем с истории о том, как появились реляционки, что это такое и чем они так привлекательны. Всем просвященным или принципиально не читающим теорию и исторические сводки можно преспокойно скипнуть дальше.  

Было время (около 1955), когда программисты были настолько суровы, что работали напрямую с диском на уровне цилиндров, секторов и головок - люди реально писали самопальные хранилища данных для конкретных дисков, выполняющие преобразование относительных адресов в абсолютные.  
Но все начало становиться интересней, когда вычислительные мощности стали расти нелинейными темпами и давали возможность развернуть схемы данных покрупнее за прежнее число валюты, но вот мозг у человеков оставался до неприличия постоянен.  
Поэтому растущая сложность такого подхода с одной стороны (попробуйте запомнить детали, какие цилиндры, размеры секторов под какую сущность заточены, когда у вас не 5-7, а хотя бы 15-17 сущностей) и увеличение объема дисков за те же деньги - с другой, привели к тому, что сильнейшие умы нашего вида стали делать именно то, что мы всегда делаем, когда хотим снизить возрастающую сложность - переход на следующий более высокий уровень абстракции. То есть мы стали подумывать над *моделями данных*.  

**Модель данных** - это, грубо говоря, какое-то описание того, по каким правилам данные будут упорядочиваться, изменяться и какие ограничения будут применены к структурам, в которых эти данные хранятся.  
Математиками быстро были синтезированы различные, говоря задним числом, немного холливарные, модели данных с такими названиями как: [сетевая](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) и [иерархическая](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85). На подробностях останавливаться не будем, но заметим немаловажный факт: по этим моделям были разработаны **системы управления базами данных** (СУБД) - программы, реализующие в себе ту или иную модель, берущие на себя все сложные алгоритмические изыски и скрывающие множество низкоуровневых деталей. Так для сетевой модели была популярна СУБД Integrated Data Store (IDS), а для иерархической - IBM Information Management System (IMS).  
Эта избавило разработчиков от заботы о низкоуровневых деталей устройства дисков и самое главное - от сложности и многообразия структур данных и алгоритмов манипуляций над ними. То есть теперь любой рядовой разраб при заканчивающимся дисковом пространстве мог относительно спокойно вмонтировать еще один диск, за вести на него еще одну СУБД и, воспользовавшись выигранным временем, пойти вмонитровать пивандрия.  
Вся эта движуха длилась до конца 60-х годов и закончилась, когда Эдгар Кодд сформулировал и изложил принципы *реляционной модели*.  

Итак, **реляционная модель** - одна из моделей данных, продукт теории построения баз данных на основе таких фундаментальных разделов математики, как теория множеств и логика (исчисление предикатов) первого порядка.
Если опустить слишком умные понятия и перейти к более прикладным, то реляцоинная модель суть есть 3 вещи:
* Данные в базе представляют собой набор отношений (таблиц) - структурный аспект;
* Отношения (таблицы) отвечают определенным условиям целостности (на них наложены определенные ограничения) - целостный аспект;
* Есть поддержка операторов манипулирования отношениями - манипуляционный аспект;  
Кроме того, в состав реляционной модели данных включают теорию *нормализации* (об этом чуть позже).

Теперь по каждому пункут человеческим языком.  
### Стурктурный аспект.  
Он фиксирует тот факт, что модель описывает любой набор данных, как *нормализованные отношения* или более русским языком - таблицы данных без избыточности информации (если не вкурили - терпим, ниже будут пояснения). 
Отношение - это формальный термин (из теории множеств) неформального слова "таблица", так что дальше интерпретируйте эти два слова, как синонимы.  

Вот формальные названия того, что из себя представляет отношение и его состовляющие:  
* *Отношение* - плоская (двумерная) таблица, состоящая из столбцов и строк;
* *Атрибут* - поименованый столбец отношения;
* *Домен* - набор допустимых значений для одного или нескольких атрибутов (столбцов);
* *Кортеж* - строка отношения (таблицы);
* *Степень* - количество атрибутов отношения;
* *Кардинальность* - количество кортежей отношения (строк таблицы);
* *Первичный ключ* (primary key) - уникальный идентификатор для таблицы;  

Также из формальных определений отношений вытекают их фундаментальные свойства:  
* Отсутствие кортежей-дубликатов (нет повторяющихся строк);
* Отсутствие упорядоченности кортежей (нет сортировки строк);
* Отсутствие упорядоченности атрибутов (нет сортировки столбцов);
* Атомарность значений атрибутов (среди значений домена не можгут содержаться множества значений - другие отношения);  
  
### Целостный аспект.  
В РМ фиксируются два базовых тербования целостности.  
Первое называется *тербованием целостности сущностей*. Оно означает, что любая строка любой таблицы отличима от любой другой строки этого отношения, т.е. любая таблица должна обладать *первичным ключом* (столбцом, значения которого всегда уникальны - нет дублирующихся). Прошаренный читатель, наверняка, заметил, что это тербование удовлетворяется автоматом, когда соблюдены базовые свойства отношений.  
Второе называется *требованием целостности по ссылкам*. Как и звучит, оно явялется более сложным, нежели первое.   
Очевидно, что многие сущности из реального мира будут представляться как две или более связанных друг с другом таблиц. Например, отделы и сотрудники: пусть первая таблица ОТДЕЛЫ описывает отделы (id, название), а вторая СОТРУДНИКИ - сотрудников: (id, имя, id_отдела). Как видно, атрибут id_отдела появляется в отношении СОТРУДНИКИ не потому, что номер отдела является собственным свойством сотрудника, а лишь для того, чтобы иметь возможность восстановить при необходимости полную сущность отдела.  
И тут становится очевидным требование того, что столбец id_отдела таблицы СОТРУДНИКИ должен соответствовать столбцу id таблицы ОТДЕЛЫ. Атрибут такого рода называется *внешним ключом* (foreign key).  
Требование целостности по ссылкам, или требование внешнего ключа состоит в том, что для каждого значения внешнего ключа, появляющегося в ссылающемся отношении, в отношении, на которое ведет ссылка, должен найтись кортеж с таким же значением первичного ключа, либо значение внешнего ключа должно быть неопределенным (т.е. ни на что не указывать). Для нашего примера это означает, что если для сотрудника указан номер отдела, то этот отдел должен существовать.  
  
### Манипуляционный аспект.
Ну ОК, мы храним данные по связным табличкам, при этом придумали туеву хучу всяких мудреных терминов, а смысл-то у этих телодвижений был? Да, мой друг, был!  
Дело в том, что теперь, благодаря такой структуре хранения данных, мы сможем прибегнуть к самой точной среди всех технических и самой технической среди всех точных дисциплин - математике! Это означает, что для описания того, как манипулировать данными (изменять, добавлять, выдергивать и т.п.) мы сможем исползовать мат. аппарат, а именно основанную на теории множеств реляционную алгебру и базирующееся на математической логике (точнее, на исчислении предикатов первого порядка) реляционное исчисление.  
Самая легендарная новость в том, что механизмы обладают одним важным свойством: они замкнуты относительно понятия отношения (таблицы). В переводе с делетантского, это означает, что выражения реляционной алгебры и формулы реляционного исчисления определяются над отношениями реляционных БД и результатом вычисления **также являются отношения**. В результате любое выражение или формула могут интерпретироваться как отношения, что позволяет использовать их в других выражениях или формулах.  
Короче говоря, мы можем сделать выборку данных, потом из этой выборки сделать другую выборку и зерультат этого извращения зафигачить в условие третей выборки! Для тех, кто видел или юзал вложенные SELECT'ы или видел JOIN'ы поймет, о чем базар.  
Чтобы проводить эти манипуляции, очевидно, должен быть какой-то язык, на котором все смогут в относительно человекочитаемой форме писать запросы к БД, которые СУБД транислирую в свое внетреннее представление и исполняют их (эту черную магию затрагивать сейчас будет неэфективно).  
И будучи солидарными с такой мыслью, сотрудники IBM в 1970 разработали экспериментальную СУБД IBM System R, для которой был создал язык SEQUEL. А позже в подполье универа Беркли была разработана некоммерческая СУБД [Ingres](https://ru.wikipedia.org/wiki/Ingres), который стал прародителем многоуважаемого [Postgres'а](https://ru.wikipedia.org/wiki/PostgreSQL).  
Потом ~~из-за неудобства набора~~ по юридическим соображениям язык SEQUEL был переименован в [SQL](https://ru.wikipedia.org/wiki/SQL).
  
### Нормализация.
*Нормализация* - это устранение избыточности и несогласованности данных. Существуют свойства, характеризующие отношение с точки зрения избыточности, они основаны на строгой теории нормализации. Каждое такое свойство называется [нормальная форма](https://ru.wikipedia.org/wiki/%D0%9D%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0).  
Погодите нервничать, если все еще непонятно, сейчас будет дан (немного грубоватый) пример.  
Итак, у нас есть набор данных о работниках какой-то фирмы, ее проектах и клиентах.
```
Сотрудники:  
- Программист Петя Дедлайнов, 32 года, работает над проектом "Ping";
- Программист Вова Дебагин, 25 лет, работает над проектом "Pong";
- Менеджер Ваня Заебцов, 29 лет, работает над проектоми "Ping" и "Pong";
Проекты:  
- Ping, заканчивающийся 2019-01-01;
- Pong, заканчивающийся 2020-02-02;
Клиенты:  
- Динг, 30 лет, заказал реализацию проекта Ping;
- Донг, 40 лет, заказал реализацию проекта Pong;
```
Наша задача составить схему данных по реляционной моделе. 
Очевидно, выделяющиеся сущность - сотрудники и клиенты, они должны будут выделены в обособленные таблицы (отношения). А вот выделять ли для проектов отдельную таблицу пытливому уму новичка может показаться неясным.  
То есть можно сделать 2 таблицы и запихать в них все:
`Сотрудники [id_сотрудника, имя, фамилия, возраст, должность, название_проекта, окончание_проекта]`
`Клиенты [id_клиента, имя, возраст, название_проекта, окончание_проекта]`
Или можно создать 3 таблицы:
`Сотрудники [id_сотрудника, имя, фамилия, возраст, id_проекта]`
`Клиенты [id_клиента, имя, возраст, id_проекта]`
`Проекты [id_проекта, название, дата_окончания]`

Вот тут-то и нужно вспомнить про нормализацию, ведь если мы проекты сделаем столбцами для каджой из двух первых таблиц, то у нас появится *избыточность*. Избыточность само по себе не является чем-то плохим (особенно финансовая), и к ней иногда прибегают для улучшения производительность запросов, умышленно прибегая к *денормализации* (процесс, обратный нормализации - нарушение нормальных форм).  
Но в чем-же опасность избыточности? Подумаешь, небольшое дублирование, ну будет у меня БД занимать на диске побольше места, память-то нынче дешева! Именно к такому выводу при поверхостном анализе приходит человечий мозг.  
Однако умные дядьки, придумавшие нормальные формы, сделали это не из любви к искусству. Дело в том, что избыточность ведет к усложнению: надо помнить, какие столбцы и где являются дубликатами друг друга, чтобы не запутаться, что из них можно использовать как аналог другого. А также, если мы, например, захотим обновить название проекта Ping, на Pink, то нам надо помнить, что мы должны сделать update двух таблиц (при чем каждой строки, где есть название этого проекта), а это уже помимо усложнения может сильно затронуть производительность. И если забыть изменить где-то название проекта, то появляется несогласованность данных (где-то название осталось старым), что может привести к, не побоюсь этого слова, неопределенности в поведении программ.  
Короче говоря, нормализация - это не конечная цель какой-либо схемы данных, а ориентир, от которого могут произойти (обоснованные) отклонения. Подробнее о том, когда можно нарушить ее принципы, можно почитать [тут](https://m.habr.com/post/64524/).  

### Подытожим об РБД и SQL.
Итак, что такое *реляционная база данных* (РБД) - это БД, основанная на одноименной модели данных (РМД). 
Но в чем же прикол этой вашей реляцоинной модели? И как она мне пригодиться в обычной жизни? - законно поинтересуются многие будущие выпускники средней школы. Но польза реляционной модели не терпит сомнений (спекулянты из Forbes впендюрили ее в список важнейших инноваций последних 85 лет).  
Она заставляет нас структурировать данные так, что их можно строго формализовать математически и удобно ими манипулировать, а также максимально оптимизировать эти манипуляции (т.к. теперь мы имеем дело с математикой, то эффективность того или иного решения можно строго доказать).  
Достоинства этой модели данных:
* Отображает информацию в наиболее простой форме;
* Основана на развитом мат. аппарате, который позволяет достаточно лаконично описать основные операции над данными и получить БД с гаранитрованными характеристиками;  

Основные (но не все) недостатки:
* Жесткость структуры данных, также есть сложность описания иерархических и сетевых связей (слабоактуален для многих современных РСУБД);
* Приходится выполнять операции соединения (JOIN'ы) и они относительно дорогие по ресурсам;  
  
## NoSQL.








